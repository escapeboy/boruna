// Realtime Notification App â€” Framework Dogfood Example
// Demonstrates: timer effects, event simulation, rate limiting, message ordering
// Uses: match expressions (F4 fix), record spread (F5 fix)

type State {
    subscribed: Int,
    events_received: Int,
    last_event_seq: Int,
    last_event_type: String,
    last_event_data: String,
    events_this_window: Int,
    rate_limit: Int,
    rate_limited_count: Int,
    poll_active: Int,
    poll_interval_ms: Int,
    total_polls: Int,
    errors: Int
}

type Msg { tag: String, payload: String }
type Effect { kind: String, payload: String, callback_tag: String }
type UpdateResult { state: State, effects: List<Effect> }
type UINode { tag: String, text: String }
type PolicySet { capabilities: List<String>, max_effects: Int, max_steps: Int }

fn init() -> State {
    State {
        subscribed: 0,
        events_received: 0,
        last_event_seq: 0,
        last_event_type: "none",
        last_event_data: "",
        events_this_window: 0,
        rate_limit: 10,
        rate_limited_count: 0,
        poll_active: 0,
        poll_interval_ms: 1000,
        total_polls: 0,
        errors: 0
    }
}

fn update(state: State, msg: Msg) -> UpdateResult {
    match msg.tag {
        "subscribe" => {
            if state.subscribed == 1 {
                UpdateResult { state: state, effects: [] }
            } else {
                UpdateResult {
                    state: State { ..state, subscribed: 1, events_this_window: 0, poll_active: 1 },
                    effects: [
                        Effect { kind: "timer", payload: "1000", callback_tag: "poll_tick" },
                    ],
                }
            }
        },
        "unsubscribe" => {
            UpdateResult {
                state: State { ..state, subscribed: 0, poll_active: 0 },
                effects: [],
            }
        },
        "poll_tick" => {
            if state.subscribed == 0 {
                UpdateResult {
                    state: State { ..state, poll_active: 0 },
                    effects: [],
                }
            } else {
                UpdateResult {
                    state: State { ..state, poll_active: 1, total_polls: state.total_polls + 1 },
                    effects: [
                        Effect { kind: "http_request", payload: "https://api.example.com/events", callback_tag: "events_received" },
                        Effect { kind: "timer", payload: "1000", callback_tag: "poll_tick" },
                    ],
                }
            }
        },
        "events_received" => {
            if state.events_this_window >= state.rate_limit {
                UpdateResult {
                    state: State { ..state, rate_limited_count: state.rate_limited_count + 1 },
                    effects: [],
                }
            } else {
                let new_seq: Int = state.last_event_seq + 1
                UpdateResult {
                    state: State { ..state, events_received: state.events_received + 1, last_event_seq: new_seq, last_event_type: "notification", last_event_data: msg.payload, events_this_window: state.events_this_window + 1 },
                    effects: [],
                }
            }
        },
        "reset_rate_window" => {
            UpdateResult {
                state: State { ..state, events_this_window: 0 },
                effects: [],
            }
        },
        "error" => {
            UpdateResult {
                state: State { ..state, last_event_type: "error", last_event_data: msg.payload, errors: state.errors + 1 },
                effects: [],
            }
        },
        _ => {
            UpdateResult { state: state, effects: [] }
        },
    }
}

fn view(state: State) -> UINode {
    if state.subscribed == 1 {
        UINode { tag: "notification-feed", text: state.last_event_data }
    } else {
        UINode { tag: "notification-feed", text: "unsubscribed" }
    }
}

fn policies() -> PolicySet {
    PolicySet {
        capabilities: ["net.fetch", "time.now"],
        max_effects: 3,
        max_steps: 1000000,
    }
}

fn main() -> Int {
    let s0: State = init()
    let r1: UpdateResult = update(s0, Msg { tag: "subscribe", payload: "" })
    let r2: UpdateResult = update(r1.state, Msg { tag: "poll_tick", payload: "" })
    let r3: UpdateResult = update(r2.state, Msg { tag: "events_received", payload: "event1" })
    let r4: UpdateResult = update(r3.state, Msg { tag: "events_received", payload: "event2" })
    let r5: UpdateResult = update(r4.state, Msg { tag: "events_received", payload: "event3" })
    r5.state.events_received
}
