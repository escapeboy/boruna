// Auth App â€” Generated from auth-app template
// App: {{app_name}}

type State {
    authenticated: Int,
    username: String,
    role: String,
    token: String,
    status: String,
    error: String,
    login_attempts: Int
}

type Msg { tag: String, payload: String }
type Effect { kind: String, payload: String, callback_tag: String }
type UpdateResult { state: State, effects: List<Effect> }
type UINode { tag: String, text: String }
type PolicySet { capabilities: List<String>, max_effects: Int, max_steps: Int }

fn init() -> State {
    State {
        authenticated: 0,
        username: "",
        role: "viewer",
        token: "",
        status: "idle",
        error: "",
        login_attempts: 0
    }
}

fn update(state: State, msg: Msg) -> UpdateResult {
    match msg.tag {
        "login" => {
            UpdateResult {
                state: State { ..state, status: "authenticating", login_attempts: state.login_attempts + 1 },
                effects: [Effect { kind: "http_request", payload: "POST /api/auth/login", callback_tag: "login_response" }],
            }
        },
        "login_response" => {
            if msg.payload == "ok" {
                UpdateResult {
                    state: State { ..state, authenticated: 1, status: "authenticated", error: "", token: "session" },
                    effects: [Effect { kind: "storage_write", payload: "token", callback_tag: "token_saved" }],
                }
            } else {
                UpdateResult {
                    state: State { ..state, status: "error", error: "invalid credentials" },
                    effects: [],
                }
            }
        },
        "token_saved" => {
            UpdateResult { state: State { ..state, status: "ready" }, effects: [] }
        },
        "logout" => {
            UpdateResult {
                state: State { ..state, authenticated: 0, username: "", role: "viewer", token: "", status: "idle" },
                effects: [Effect { kind: "storage_delete", payload: "token", callback_tag: "token_cleared" }],
            }
        },
        "token_cleared" => {
            UpdateResult { state: State { ..state, status: "idle" }, effects: [] }
        },
        "set_role" => {
            UpdateResult {
                state: State { ..state, role: msg.payload },
                effects: [],
            }
        },
        "check_session" => {
            UpdateResult {
                state: State { ..state, status: "checking" },
                effects: [Effect { kind: "storage_read", payload: "token", callback_tag: "session_checked" }],
            }
        },
        "session_checked" => {
            if msg.payload == "" {
                UpdateResult { state: State { ..state, status: "idle", authenticated: 0 }, effects: [] }
            } else {
                UpdateResult { state: State { ..state, status: "authenticated", authenticated: 1, token: msg.payload }, effects: [] }
            }
        },
        _ => {
            UpdateResult { state: state, effects: [] }
        },
    }
}

fn view(state: State) -> UINode {
    if state.authenticated == 1 {
        UINode { tag: "dashboard", text: state.username }
    } else {
        UINode { tag: "login-form", text: state.status }
    }
}

fn policies() -> PolicySet {
    PolicySet { capabilities: ["net.fetch", "fs.read", "fs.write"], max_effects: 3, max_steps: 1000000 }
}

fn main() -> Int {
    let s0: State = init()
    let r1: UpdateResult = update(s0, Msg { tag: "login", payload: "" })
    let r2: UpdateResult = update(r1.state, Msg { tag: "login_response", payload: "ok" })
    let r3: UpdateResult = update(r2.state, Msg { tag: "token_saved", payload: "" })
    r3.state.authenticated
}
